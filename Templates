Understood, here is the updated generalized script to handle cases where the date might be concatenated with other field values. The script will extract the date based on the given patterns and reformat it accordingly.

```python
import pandas as pd
import re
from datetime import datetime

# Function to parse the date from a string
def parse_date(date_str):
    date_formats = ['%m%d%Y', '%m/%d/%Y', '%m/%d/%y', '%m%d%y', '%Y%m%d']
    for date_format in date_formats:
        try:
            return pd.to_datetime(date_str, format=date_format)
        except ValueError:
            continue
    raise ValueError(f"Date format not recognized: {date_str}")

# Function to identify and extract date from a line
def extract_date_from_line(line):
    current_year = datetime.now().year
    date_patterns = [
        r'(?<=\d)(\d{8})(?=[ \tA-Za-z])',         # Matches YYYYMMDD
        r'(?<=\d)(\d{1,2}/\d{1,2}/\d{4})(?=[ \tA-Za-z])',  # Matches MM/DD/YYYY
        r'(?<=\d)(\d{1,2}/\d{1,2}/\d{2})(?=[ \tA-Za-z])',  # Matches MM/DD/YY
        r'(?<=\d)(\d{1,2}\d{1,2}\d{4})(?=[ \tA-Za-z])',    # Matches MMDDYYYY
        r'(?<=\d)(\d{1,2}\d{1,2}\d{2})(?=[ \tA-Za-z])'     # Matches MMDDYY
    ]
    
    for pattern in date_patterns:
        match = re.search(pattern, line)
        if match:
            date_str = match.group()
            try:
                parsed_date = parse_date(date_str)
                if parsed_date.year <= current_year:  # Ensure the date is not in the future
                    return parsed_date.strftime('%m-%d-%Y')
            except ValueError:
                continue
    raise ValueError("Date format not recognized or date not found in line")

# Function to extract dates from the text file and create a series
def extract_dates(file_path):
    dates = []
    with open(file_path, 'r') as file:
        lines = file.readlines()
        for line in lines:
            try:
                parsed_date = extract_date_from_line(line)
                dates.append(parsed_date)
            except ValueError as e:
                print(f"Error parsing date on line: {line}. Error: {e}")
    
    date_series = pd.Series(dates, name='Date')
    return date_series

# Main function to create a DataFrame with the date series
def main():
    file_path = input("Enter the path of the txt file to process: ")
    
    try:
        date_series = extract_dates(file_path)
        print(date_series.head())
        # You can add more series here and create a DataFrame
        # Example:
        # df = pd.DataFrame({
        #     'Date': date_series,
        #     'OtherColumn': other_series,
        #     ...
        # })
        # print(df.head())
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()
```

### Explanation:
1. **Regular Expressions**:
   - The regular expressions in `date_patterns` will match dates based on the conditions you provided: 
     - A date is preceded by a digit (`(?<=\d)`)
     - Followed by a space, tab, or alphabetic character (`(?=[ \tA-Za-z])`).

2. **Date Parsing**:
   - `parse_date` function attempts to parse the date using multiple formats.
   - Reformats the date to 'MM-DD-YYYY'.

3. **Extracting Dates from Lines**:
   - `extract_date_from_line` processes each line to identify and extract the date.
   - Ensures that the date is not in the future based on the current year.

4. **Creating a Pandas Series**:
   - `extract_dates` function reads the file, extracts dates from each line, and creates a pandas Series.

5. **Main Function**:
   - The `main` function handles user input for the file path, processes the file, and prints the resulting date series.

This script generalizes the extraction of dates that might be concatenated with other values and formats them as requested.
