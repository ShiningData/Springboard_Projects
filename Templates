If you're calling Java directly from your Python script, you're likely using a bridge technology like JPype, Py4J, or JayDeBeApi. In this case, the memory issues are still occurring in the Java Virtual Machine (JVM) that's being spawned by your Python process, not in Python itself.

Here's how to address Java memory issues when calling Java from Python:

### 1. Set JVM Parameters When Initializing Java

If you're using JPype, you can set memory parameters when starting the JVM:

```python
import jpype

# Set JVM memory options before starting
jpype.startJVM(jpype.getDefaultJVMPath(), 
               "-Xmx4g",  # Maximum heap size (4GB in this example)
               "-Xms1g",  # Initial heap size
               classpath="path/to/your/java/classes")
```

For Py4J, you might need to configure the gateway:

```python
from py4j.java_gateway import JavaGateway, GatewayParameters, launch_gateway

# Launch JVM with custom parameters
port = launch_gateway(jarpath="path/to/py4j.jar", 
                      die_on_exit=True,
                      javaopts=["-Xmx4g", "-XX:+UseG1GC"])

gateway = JavaGateway(gateway_parameters=GatewayParameters(port=port))
```

### 2. Check Which Java Bridge You're Using

First, identify which Java bridge technology your code is using. Look for imports like:
- `import jpype`
- `import py4j`
- `import jaydebeapi`

### 3. Optimize Your Algorithm

If you can't allocate more memory:
- Process data in smaller batches
- Reduce the number of models in your ensemble
- Add explicit calls to release resources when they're no longer needed

### 4. Monitor Memory Usage

Add code to monitor memory consumption:

```python
# For monitoring Python memory
import psutil
process = psutil.Process()
print(f"Memory usage: {process.memory_info().rss / 1024 / 1024:.2f} MB")

# For monitoring JVM memory if using JPype
if "jpype" in sys.modules:
    runtime = jpype.java.lang.Runtime.getRuntime()
    total_memory = runtime.totalMemory() / 1024 / 1024
    free_memory = runtime.freeMemory() / 1024 / 1024
    used_memory = total_memory - free_memory
    print(f"JVM Memory: Used {used_memory:.2f} MB, Free {free_memory:.2f} MB, Total {total_memory:.2f} MB")
```

Could you share which specific Java bridge you're using and a simplified version of how you're initializing it? That would help me provide more specific guidance.
