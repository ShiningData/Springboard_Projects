import tensorflow as tf

# Define custom metrics
def mape(y_true, y_pred):
    diff = tf.abs((y_true - y_pred) / tf.maximum(tf.abs(y_true), tf.keras.backend.epsilon()))
    return 100.0 * tf.reduce_mean(tf.where(tf.math.is_finite(diff), diff, tf.zeros_like(diff)))

def smape(y_true, y_pred):
    denominator = tf.maximum(tf.abs(y_true) + tf.abs(y_pred), tf.keras.backend.epsilon())
    diff = tf.abs(y_true - y_pred) / denominator
    return 200.0 * tf.reduce_mean(tf.where(tf.math.is_finite(diff), diff, tf.zeros_like(diff)))

# Create the metrics objects
mape_metric = tf.keras.metrics.Mean(name='mape')
smape_metric = tf.keras.metrics.Mean(name='smape')
rmse_metric = tf.keras.metrics.RootMeanSquaredError(name='rmse')
mae_metric = tf.keras.metrics.MeanAbsoluteError(name='mae')

# Example usage:
y_true = tf.constant([10.0, 20.0, 30.0])
y_pred = tf.constant([8.0, 18.0, 33.0])

mape_metric.update_state(y_true, y_pred)
smape_metric.update_state(y_true, y_pred)
rmse_metric.update_state(y_true, y_pred)
mae_metric.update_state(y_true, y_pred)

print("MAPE:", mape_metric.result().numpy())
print("sMAPE:", smape_metric.result().numpy())
print("RMSE:", rmse_metric.result().numpy())
print("MAE:", mae_metric.result().numpy())
